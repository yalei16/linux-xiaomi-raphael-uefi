name: 构建 Kali Boot 镜像

on:
  workflow_dispatch:
    inputs:
      kernel_version:
        description: '内核版本号（如 6.18）'
        required: true
        type: string
      rootfs_tag:
        description: 'rootfs 镜像的 release tag（如 kali-kali-desktop-6.18）'
        required: true
        type: string

jobs:
  build-boot:
    runs-on: ubuntu-24.04-arm
    
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
      
      - name: 安装依赖
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            mtools dosfstools e2fsprogs xz-utils wget cpio
      
      - name: 下载内核包
        run: |
          mkdir -p build
          cd build
          
          echo ">>> 下载内核包..."
          wget -q --show-progress "https://github.com/yalei16/linux-xiaomi-raphael-uefi/releases/download/kernel-v6.18/linux-image-xiaomi-raphael.deb"
          wget -q --show-progress "https://github.com/yalei16/linux-xiaomi-raphael-uefi/releases/download/kernel-v6.18/linux-headers-xiaomi-raphael.deb"
          wget -q --show-progress "https://github.com/yalei16/linux-xiaomi-raphael-uefi/releases/download/kernel-v6.18/firmware-xiaomi-raphael.deb"
          wget -q --show-progress "https://github.com/yalei16/linux-xiaomi-raphael-uefi/releases/download/kernel-v6.18/alsa-xiaomi-raphael.deb"
          
          ls -la *.deb
      
      - name: 提取内核文件
        run: |
          cd build
          mkdir -p kernel-extract
          cd kernel-extract
          
          # 解压 deb 包
          ar x ../linux-image-xiaomi-raphael.deb
          
          # 查看解压出的文件
          echo ">>> 解压出的文件:"
          ls -la
          
          # 查找 data.tar.*（可能是 .xz 或 .gz）
          DATA_TAR=$(ls data.tar.* 2>/dev/null | head -1)
          
          if [ -z "$DATA_TAR" ]; then
            echo "错误: 找不到 data.tar.* 文件"
            exit 1
          fi
          
          echo ">>> 解压 $DATA_TAR"
          tar -xf "$DATA_TAR"
          
          # 查找内核文件
          echo ">>> 查找内核文件..."
          find . -name "vmlinuz-*" -o -name "Image-*" 2>/dev/null | head -5
          find . -name "*.dtb" 2>/dev/null | head -5
          
          # 复制内核文件到 build 目录
          KERNEL_FILE=$(find . -name "vmlinuz-*" | head -1)
          
          if [ -z "$KERNEL_FILE" ]; then
            # 尝试找 Image 文件
            KERNEL_FILE=$(find . -name "Image-*" -o -name "Image" | head -1)
          fi
          
          if [ -z "$KERNEL_FILE" ]; then
            echo "错误: 找不到内核文件 (vmlinuz-* 或 Image-*)"
            find . -type f | head -20
            exit 1
          fi
          
          cp "$KERNEL_FILE" ../vmlinuz
          
          # 查找 dtb 文件
          DTB_FILE=$(find . -path "*/qcom/sm8150-xiaomi-raphael.dtb" | head -1)
          if [ -z "$DTB_FILE" ]; then
            DTB_FILE=$(find . -name "*raphael*.dtb" | head -1)
          fi
          if [ -z "$DTB_FILE" ]; then
            DTB_FILE=$(find . -name "sm8150*.dtb" | head -1)
          fi
          
          if [ -n "$DTB_FILE" ]; then
            cp "$DTB_FILE" ../dtb
            echo ">>> 找到 dtb: $DTB_FILE"
          else
            echo "警告: 未找到 dtb 文件"
          fi
          
          # 获取内核版本
          KERNEL_VERSION=$(basename "$KERNEL_FILE" | sed 's/vmlinuz-//' | sed 's/Image-//')
          echo "KERNEL_VERSION=$KERNEL_VERSION" >> $GITHUB_ENV
          echo ">>> 内核版本: $KERNEL_VERSION"
          
          cd ..
          ls -la vmlinuz dtb 2>/dev/null || ls -la vmlinuz
      
      - name: 创建 initramfs
        run: |
          cd build
          
          # 创建临时目录构建 initramfs
          mkdir -p initramfs/{bin,sbin,lib,lib64,usr,dev,proc,sys,tmp,run,etc}
          
          # 安装 busybox
          sudo apt-get install -y busybox-static
          
          # 创建基本 init 脚本
          cat > initramfs/init << 'INITEOF'
          #!/bin/sh
          
          # 挂载基本文件系统
          mount -t proc none /proc
          mount -t sysfs none /sys
          mount -t devtmpfs none /dev
          
          # 等待设备就绪
          sleep 2
          
          # 查找根分区
          ROOT_PART="/dev/sda33"
          
          # 如果 PARTLABEL 存在，使用它
          if [ -e /dev/disk/by-partlabel/linux ]; then
            ROOT_PART="/dev/disk/by-partlabel/linux"
          fi
          
          # 挂载根文件系统
          mkdir -p /mnt/root
          mount -t ext4 "$ROOT_PART" /mnt/root || {
            echo "等待根分区就绪..."
            sleep 5
            mount -t ext4 "$ROOT_PART" /mnt/root
          }
          
          # 切换到真正的根文件系统
          cd /mnt/root
          mkdir -p oldroot
          
          # 挂载虚拟文件系统到新的根
          mount --move /proc /mnt/root/proc
          mount --move /sys /mnt/root/sys
          mount --move /dev /mnt/root/dev
          
          # 切换根并执行 init
          exec switch_root /mnt/root /sbin/init
          INITEOF
          
          chmod +x initramfs/init
          
          # 复制 busybox 并创建链接
          cp /bin/busybox initramfs/bin/
          cd initramfs/bin
          for cmd in sh echo mount umount sleep mkdir cat ln ls; do
            ln -s busybox $cmd
          done
          cd ../..
          
          # 创建必要的设备节点
          mkdir -p initramfs/dev
          mknod initramfs/dev/null c 1 3 2>/dev/null || true
          mknod initramfs/dev/console c 5 1 2>/dev/null || true
          
          # 打包 initramfs
          cd initramfs
          find . | cpio -o -H newc | gzip > ../initrd.img
          cd ..
          
          ls -la initrd.img
      
      - name: 创建 GRUB 配置
        run: |
          cd build
          KERNEL_VERSION="${{ env.KERNEL_VERSION }}"
          
          mkdir -p boot/grub
          
          cat > boot/grub/grub.cfg << EOF
          set timeout=10
          set default=0
          
          # 加载必要模块
          insmod gzio
          insmod part_gpt
          insmod ext2
          
          menuentry 'Kali Linux' --class kali --class gnu-linux --class gnu --class os {
              search --no-floppy --part-label linux --set=root
              
              linux /vmlinuz root=/dev/sda33 ro console=tty0 console=ttyMSM0,115200n8
              initrd /initrd.img
              devicetree /dtb
          }
          
          menuentry 'Kali Linux (Recovery)' --class kali --class gnu-linux --class gnu --class os {
              search --no-floppy --part-label linux --set=root
              
              linux /vmlinuz root=/dev/sda33 ro single debug console=tty0 console=ttyMSM0,115200n8
              initrd /initrd.img
              devicetree /dtb
          }
          EOF
          
          # 复制内核文件到 boot 目录
          cp vmlinuz boot/
          cp initrd.img boot/
          [ -f dtb ] && cp dtb boot/
          
          ls -la boot/
          cat boot/grub/grub.cfg
      
      - name: 创建 boot.img（FAT32 格式）
        run: |
          cd build
          
          # 创建 128MB 的 boot.img
          BOOT_SIZE=128M
          truncate -s $BOOT_SIZE boot.img
          
          # 格式化为 FAT32
          mkfs.vfat -F32 -n "KALI-BOOT" boot.img
          
          # 使用 mtools 复制文件
          mcopy -i boot.img boot/vmlinuz ::vmlinuz
          mcopy -i boot.img boot/initrd.img ::initrd.img
          [ -f boot/dtb ] && mcopy -i boot.img boot/dtb ::dtb
          
          # 创建 EFI/boot 目录结构
          mmd -i boot.img ::EFI
          mmd -i boot.img ::EFI/boot
          mcopy -i boot.img boot/grub/grub.cfg ::EFI/boot/grub.cfg
          
          # 尝试获取 GRUB EFI 文件
          echo ">>> 查找 GRUB EFI 文件..."
          find /usr -name "grubaa64.efi" -o -name "grub.efi" 2>/dev/null | head -5
          
          # 复制 GRUB EFI 文件
          GRUB_EFI=$(find /usr -name "grubaa64.efi" 2>/dev/null | head -1)
          if [ -z "$GRUB_EFI" ]; then
            GRUB_EFI=$(find /usr -name "grub.efi" 2>/dev/null | head -1)
          fi
          
          if [ -n "$GRUB_EFI" ]; then
            echo ">>> 使用 GRUB EFI: $GRUB_EFI"
            mcopy -i boot.img "$GRUB_EFI" ::EFI/boot/BOOTAA64.EFI
          else
            echo "警告: 未找到 GRUB EFI 文件，尝试安装 grub-efi-arm64"
            sudo apt-get install -y grub-efi-arm64-bin
            GRUB_EFI=$(find /usr -name "grubaa64.efi" 2>/dev/null | head -1)
            if [ -n "$GRUB_EFI" ]; then
              mcopy -i boot.img "$GRUB_EFI" ::EFI/boot/BOOTAA64.EFI
            else
              echo "错误: 无法找到 GRUB EFI 文件"
              exit 1
            fi
          fi
          
          # 验证内容
          echo ">>> boot.img 内容:"
          mdir -i boot.img ::
          mdir -i boot.img ::EFI/boot
          
          # 压缩
          xz -T0 -v boot.img
      
      - name: 发布 Boot 镜像
        uses: softprops/action-gh-release@v1
        with:
          tag_name: boot-${{ github.event.inputs.kernel_version }}
          name: "Kali Boot Image ${{ github.event.inputs.kernel_version }}"
          files: build/boot.img.xz
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
